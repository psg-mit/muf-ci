(*
lambda1 - symbolic
lambda2 - symbolic
tau - symbolic
*)

val preprocess_data = fun entry -> List.hd(entry) in

val add_data = fun (x, y) -> x + y in

val mean = fun data ->
  let sum = fold(add_data, data, 0.) in
  let n = List.len(data) in
  sum / n
in

val step = fun (count_obs, (tau, lambda1, lambda2, i)) ->
  let lambda = if i < tau then lambda1 else lambda2 in

  let () = observe(poisson(lambda), count_obs) in

  let () = resample() in
  (tau, lambda1, lambda2, i + 1)
in

(* observations *)
let data = List.map(preprocess_data, File.read("data/processed_data.csv")) in

let n_data = List.len(data) in
let alpha = 1 / mean(data) in

let symbolic lambda1 <- exponential(alpha) in
let symbolic lambda2 <- exponential(alpha) in
let symbolic tau <- uniform_int(0, n_data - 1) in
let (tau, lambda1, lambda2, _) = fold(step, data, (tau, lambda1, lambda2, 0)) in
(tau, lambda1, lambda2)